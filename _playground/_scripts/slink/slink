#!/bin/zsh

#-->> Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

#--<<
#-->> Print colored output
print_status() {
    echo -e "${BLUE}[INFO] $1${NC} $2"
}

print_success() {
    echo -e "${GREEN}✔ $1${NC} $2"
}

print_warning() {
    echo -e "${YELLOW}❕ $1${NC} $2"
}

print_error() {
    echo -e "${RED}✘ $1${NC} $2"
}

# Symlink database file
SYMLINK_DB="/home/pi/.symlink-db"

# Database helper functions - REWRITTEN WITHOUT COMMAND SUBSTITUTION
_symlink_db_init() {
    if [[ ! -f "$SYMLINK_DB" ]]; then
        touch "$SYMLINK_DB"
    fi
}

_symlink_db_add() {
    local srcPath="$1"
    local destPath="$2"
    # Use zsh's built-in date formatting instead of command substitution
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    _symlink_db_init
    echo "$timestamp|$srcPath|$destPath" >> "$SYMLINK_DB"
}

_symlink_db_remove() {
    local path="$1"
    
    _symlink_db_init
    
    # Use zsh parameter expansion instead of sed for escaping
    local escaped_path="${path//[][\.*^$()+?{|]/\\}"
    
    # Use zsh built-ins to filter the database
    local temp_file="${SYMLINK_DB}.tmp"
    > "$temp_file"  # Clear temp file
    
    while IFS='|' read -r timestamp src dest; do
        # Check if either source or destination matches the path
        if [[ "$src" != "$path" && "$dest" != "$path" ]]; then
            echo "$timestamp|$src|$dest" >> "$temp_file"
        fi
    done < "$SYMLINK_DB"
    
    mv "$temp_file" "$SYMLINK_DB"
}

_symlink_db_find() {
    local path="$1"
    
    _symlink_db_init
    
    # Use zsh parameter expansion instead of sed for escaping
    local escaped_path="${path//[][\.*^$()+?{|]/\\}"
    
    # Use zsh built-ins to search the database
    while IFS='|' read -r timestamp src dest; do
        if [[ "$src" == "$path" || "$dest" == "$path" ]]; then
            echo "$timestamp|$src|$dest"
        fi
    done < "$SYMLINK_DB"
}

slink() { #>
    local remove_flag=false
    local path=""
    
    # Check for remove flag
    if [[ "$1" == "-r" || "$1" == "--remove" ]]; then
        remove_flag=true
        path="$2"
    else
        path="$1"
    fi
    
    # If no path provided, show usage
    if [[ -z "$path" ]]; then
        echo "Usage:"
        echo "  slink <source> <destination>     # Create symlink"
        echo "  slink -r <path>                  # Remove symlink (by source or destination)"
        echo "  slink --list                     # List tracked symlinks"
        return 1
    fi
    
    # Handle list command
    if [[ "$path" == "--list" ]]; then
        echo "=== TRACKED SYMLINKS ==="
        if [[ -f "$SYMLINK_DB" && -s "$SYMLINK_DB" ]]; then
            while IFS='|' read -r timestamp src dest; do
                echo "$timestamp: $src --> $dest"
            done < "$SYMLINK_DB"
        else
            echo "No tracked symlinks found."
        fi
        return 0
    fi
    
    # Handle removal
    if [[ "$remove_flag" == true ]]; then
        # Find the symlink in our database
        local db_entry=$(_symlink_db_find "$path")
        
        if [[ -n "$db_entry" ]]; then
            # Use zsh array splitting instead of cut
            local parts=(${(s:|:)db_entry})
            local srcPath="$parts[2]"
            local destPath="$parts[3]"
            
            # Determine which path is the actual symlink (destination)
            local symlink_path=""
            if [[ -L "$destPath" ]]; then
                symlink_path="$destPath"
            elif [[ -L "$srcPath" ]]; then
                symlink_path="$srcPath"
            else
                print_warning "Found database entry but symlink not found: " "$path"
                return 1
            fi
            
            # Remove the symlink
            if sudo unlink "$symlink_path" 2>/dev/null; then
                _symlink_db_remove "$path"
                print_success "Symlink removed and database updated: " "$symlink_path"
            else
                print_error "Failed to remove symlink: " "$symlink_path"
                return 1
            fi
        else
            # Not in database, try to remove anyway
            if [[ -L "$path" ]]; then
                if sudo unlink "$path" 2>/dev/null; then
                    print_success "Symlink removed (not tracked): " "$path"
                else
                    print_error "Failed to remove symlink: " "$path"
                    return 1
                fi
            else
                print_warning "Path is not a symlink: " "$path"
                return 1
            fi
        fi
        return 0
    fi
    
    # Handle creation (original functionality)
    local srcPath="$1"
    local destPath="$2"
    
    if [[ -z "$destPath" ]]; then
        print_error "Missing destination path for symlink creation"
        return 1
    fi
    
    # Create the symlink
    sudo ln -sf "$srcPath" "$destPath"
    
    if [[ -L "$destPath" ]]; then
        if [[ -r "$destPath" && -w "$destPath" ]]; then
            _symlink_db_add "$srcPath" "$destPath"
            print_success "Symlink created and tracked: " "$srcPath --> $destPath"
        else
            print_error "Symlink exists but is not writable: " "$srcPath --> $destPath"
        fi
    else
        print_error "Symlink was not created: " "$srcPath --> $destPath"
    fi
} #<

# If script is executed directly (not sourced), run the slink function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    slink "$@"
fi